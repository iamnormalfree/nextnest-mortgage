import { Worker, Job } from 'bullmq';
import { getRedisConnection } from './redis-config';
import { BrokerConversationJob } from './broker-queue';

// ============================================================================
// IMPORT EXISTING FUNCTIONS (DO NOT RECREATE THESE)
// ============================================================================
// These functions are already implemented and tested in the existing codebase.
// The worker calls them, preserving all existing business logic.

// Broker assignment and metrics
import { assignBestBroker, updateBrokerMetrics, getBrokerForConversation } from '@/lib/ai/broker-assignment';

// Broker capacity management
import { markBrokerBusy, releaseBrokerCapacity } from '@/lib/ai/broker-availability';

// Response timing calculation
import { analyzeMessageUrgency } from '@/lib/calculations/broker-persona';

// Chatwoot integration
import { ChatwootClient } from '@/lib/integrations/chatwoot-client';

// AI response generation (NEW - Phase 2)
import { generateBrokerResponse } from '@/lib/ai/broker-ai-service';

// AI Orchestrator (Week 5 - Full Intelligence Integration)
import { getAIOrchestrator } from '@/lib/ai/ai-orchestrator';
import { updateTimingData } from "./broker-queue";
import { isFullAIIntelligenceEnabled } from '@/lib/utils/feature-flags';

// ============================================================================
// WORKER IMPLEMENTATION
// ============================================================================

/**
 * Process broker conversation job
 *
 * CRITICAL INTEGRATION POINTS:
 * This worker integrates with ALL existing NextNest systems without recreating them:
 *
 * 1. Broker Assignment (lib/ai/broker-assignment.ts)
 *    - assignBestBroker() - Assigns broker based on lead score
 *    - updateBrokerMetrics() - Tracks conversation metrics
 *    - getBrokerForConversation() - Retrieves assigned broker
 *
 * 2. Capacity Management (lib/ai/broker-availability.ts)
 *    - markBrokerBusy() - Increments broker workload
 *    - releaseBrokerCapacity() - Decrements broker workload
 *
 * 3. Response Timing (lib/calculations/broker-persona.ts)
 *    - analyzeMessageUrgency() - Calculates human-like delays (1-6s)
 *    - getBrokerPersona() - Retrieves broker persona definition
 *
 * 4. Chatwoot Client (lib/integrations/chatwoot-client.ts)
 *    - sendInitialMessage() - Sends greeting with deduplication
 *    - updateConversationCustomAttributes() - Stores metadata
 *    - createActivityMessage() - System notifications
 *
 * NO EXISTING FUNCTIONS ARE RECREATED HERE - ALL ARE IMPORTED AND CALLED
 */
async function processConversationJob(job: Job<BrokerConversationJob>) {
  const { data } = job;
  const startTime = Date.now();
// Phase 1 Day 1: Capture worker start timestamp for SLA measurement  if (data.timingData && data.timingData.messageId) {    try {      await updateTimingData(        data.conversationId,        data.timingData.messageId,        { workerStartTimestamp: startTime }      );      console.log(`‚è±Ô∏è Worker start timestamp captured: ${new Date(startTime).toISOString()}`);    } catch (timingError) {      console.error("‚ùå Failed to capture worker start timestamp:", timingError);      // Non-critical - do not fail the job    }  }

  console.log(`\n${'='.repeat(60)}`);
  console.log(`ü§ñ Processing ${data.type} for conversation ${data.conversationId}`);
  console.log(`   Broker: ${data.brokerName || 'To be assigned'}`);
  console.log(`   Lead Score: ${data.processedLeadData.leadScore}`);
  console.log(`${'='.repeat(60)}\n`);

  try {
    if (data.type === 'new-conversation') {
      await processNewConversation(job);
    } else if (data.type === 'incoming-message') {
      await processIncomingMessage(job);
    } else {
      throw new Error(`Unknown job type: ${(data as any).type}`);
    }

    const duration = Date.now() - startTime;
    console.log(`\n‚úÖ Job completed successfully in ${duration}ms\n`);

    return {
      status: 'completed',
      conversationId: data.conversationId,
      duration,
    };

  } catch (error) {
    const duration = Date.now() - startTime;
    console.error(`\n‚ùå Job failed after ${duration}ms:`, error);

    // Try to release broker capacity even on error
    if (data.brokerId) {
      try {
        await releaseBrokerCapacity(data.brokerId);
        console.log('‚úÖ Broker capacity released after error');
      } catch (releaseError) {
        console.error('‚ùå Failed to release broker capacity:', releaseError);
      }
    }

    // On final failure, escalate to human
    if (job.attemptsMade >= 2) {
      console.error('‚ùå All retries exhausted, escalating to human');
      try {
        const chatwootClient = new ChatwootClient();
        await chatwootClient.createActivityMessage(
          data.conversationId,
          "‚ö†Ô∏è AI system experiencing technical difficulties. A human specialist will be with you shortly."
        );
      } catch (escalationError) {
        console.error('‚ùå Failed to send escalation message:', escalationError);
      }
    }

    throw error; // Re-throw for BullMQ retry logic
  }
}

/**
 * Process new conversation (initial greeting)
 *
 * FLOW:
 * 1. Assign broker (EXISTING: assignBestBroker from broker-assignment.ts)
 * 2. Mark busy (EXISTING: markBrokerBusy from broker-availability.ts)
 * 3. Update attributes (EXISTING: updateConversationCustomAttributes from chatwoot-client.ts)
 * 4. Post activity (EXISTING: createActivityMessage from chatwoot-client.ts)
 * 5. Send greeting (EXISTING: sendInitialMessage from chatwoot-client.ts)
 * 6. Update metrics (EXISTING: updateBrokerMetrics from broker-assignment.ts)
 * 7. Release capacity (EXISTING: releaseBrokerCapacity from broker-availability.ts)
 */
async function processNewConversation(job: Job<BrokerConversationJob>) {
  const { data } = job;

  // STEP 1: Assign broker (EXISTING FUNCTION)
  // Location: lib/ai/broker-assignment.ts:4-144
  console.log('üìä Step 1: Assigning broker...');
  const broker = await assignBestBroker(
    data.processedLeadData.leadScore,
    data.processedLeadData.loanType,
    data.processedLeadData.propertyType || data.processedLeadData.propertyCategory || '',
    data.processedLeadData.actualIncomes?.[0] || 0,
    'immediate', // timeline
    data.conversationId
  );

  if (!broker) {
    throw new Error('Failed to assign broker - no brokers available');
  }

  console.log('‚úÖ Broker assigned:', {
    id: (broker as any).id,
    name: (broker as any).name,
    personality_type: (broker as any).personality_type,
  });

  // STEP 2: Mark broker as busy (EXISTING FUNCTION)
  // Location: lib/ai/broker-availability.ts:12-38
  // NOTE: This is already called by assignBestBroker, but we ensure it's done
  console.log('üìä Step 2: Ensuring broker capacity reserved...');
  // Already done in assignBestBroker, so we skip this

  // STEP 3: Update conversation attributes (EXISTING METHOD)
  // Location: lib/integrations/chatwoot-client.ts
  console.log('üì§ Step 3: Updating conversation attributes...');
  const chatwootClient = new ChatwootClient();

  await chatwootClient.updateConversationCustomAttributes(
    data.conversationId,
    {
      broker_id: (broker as any).id,
      broker_name: (broker as any).name,
      broker_personality: (broker as any).personality_type,
      lead_score: data.processedLeadData.leadScore,
      loan_type: data.processedLeadData.loanType,
      property_type: data.processedLeadData.propertyType || data.processedLeadData.propertyCategory,
      monthly_income: data.processedLeadData.actualIncomes?.[0],
      employment_type: data.processedLeadData.employmentType,
      ai_status: 'bot_active',
    }
  );
  console.log('‚úÖ Conversation attributes updated');

  // STEP 4: Post activity message (EXISTING METHOD with delay)
  // Location: lib/integrations/chatwoot-client.ts
  if (!data.skipGreeting) {
    console.log('üì¢ Step 4: Posting broker join activity...');
    await delay(500); // Human-like delay
    await chatwootClient.createActivityMessage(
      data.conversationId,
      `ü§ù ${(broker as any).name} has joined the conversation`
    );
    console.log('‚úÖ Activity message posted');
  }

  // STEP 5: Send initial greeting (EXISTING METHOD with delay)
  // Location: lib/integrations/chatwoot-client.ts:415-494
  // This method has built-in deduplication via hasExistingGreeting()
  if (!data.skipGreeting) {
    console.log('üí¨ Step 5: Sending initial greeting...');
    await delay(2000); // Human-like delay
    await chatwootClient.sendInitialMessage(
      data.conversationId,
      data.processedLeadData
    );
    console.log('‚úÖ Initial greeting sent');
  } else {
    console.log('‚è≠Ô∏è Step 5: Skipping greeting (conversation reopen)');
  }

  // STEP 6: Update metrics (EXISTING FUNCTION)
  // Location: lib/ai/broker-assignment.ts:167-201
  console.log('üìà Step 6: Updating broker metrics...');
  await updateBrokerMetrics(
    data.conversationId,
    (broker as any).id,
    1, // message_count
    false, // handoffTriggered
    undefined // handoffReason
  );
  console.log('‚úÖ Metrics updated');

  // STEP 7: Release broker capacity (EXISTING FUNCTION)
  // Location: lib/ai/broker-availability.ts:40-81
  // NOTE: Capacity is managed by markBrokerBusy/releaseBrokerCapacity
  // We keep broker busy until conversation is complete or handed off
  console.log('üíº Broker remains assigned to conversation');
}

/**
 * Process incoming message (AI response)
 *
 * FLOW:
 * 1. Get broker assignment (EXISTING: getBrokerForConversation from broker-assignment.ts)
 * 2. Analyze urgency (EXISTING: analyzeMessageUrgency from broker-persona.ts)
 * 3. Wait for response timing (EXISTING LOGIC: calculated delays)
 * 4. Generate AI response (NEW: to be added in Phase 2)
 * 5. Send response (NEW METHOD: to be added to chatwoot-client.ts in Phase 2)
 * 6. Check for handoff (EXISTING: based on analyzeMessageUrgency)
 * 7. Update metrics (EXISTING: updateBrokerMetrics from broker-assignment.ts)
 * 8. Release capacity if needed (EXISTING: releaseBrokerCapacity from broker-availability.ts)
 *
 * NOTE: This function is a placeholder for Phase 2 when AI response generation is added.
 * For now, it demonstrates the integration points with existing functions.
 */
async function processIncomingMessage(job: Job<BrokerConversationJob>) {
  const { data } = job;

  // STEP 1: Get broker assignment (EXISTING FUNCTION)
  // Location: lib/ai/broker-assignment.ts:146-165
  console.log('üìä Step 1: Getting broker assignment...');
  let broker: any;

  if (data.brokerId) {
    // Broker already assigned
    broker = { id: data.brokerId, name: data.brokerName };
  } else {
    // Get from database
    broker = await getBrokerForConversation(data.conversationId);
    if (!broker) {
      throw new Error('No broker assigned to this conversation');
    }
  }
  console.log('‚úÖ Broker found:', broker.name);

  // STEP 2: Get broker persona (from job data)
  console.log('üé≠ Step 2: Getting broker persona...');
  const persona = data.brokerPersona;
  if (!persona) {
    throw new Error('Broker persona not found in job data');
  }
  console.log('‚úÖ Persona loaded:', persona.name);

  // STEP 3: Analyze message urgency (EXISTING FUNCTION)
  // Location: lib/calculations/broker-persona.ts:154-189
  console.log('‚è±Ô∏è Step 3: Analyzing message urgency...');
  const urgency = analyzeMessageUrgency(
    data.userMessage || '',
    persona
  );
  console.log('‚úÖ Urgency analyzed:', {
    responseTime: `${urgency.responseTime}ms`,
    isUrgent: urgency.isUrgent,
    escalate: urgency.escalate,
  });

  // STEP 4: Wait for natural timing (EXISTING LOGIC)
  console.log(`‚è≥ Step 4: Waiting ${urgency.responseTime}ms for natural timing...`);
  await delay(urgency.responseTime);
  console.log('‚úÖ Wait complete');

  // STEP 5: Generate AI response
  // Week 5: Route through AI Orchestrator if feature flag enabled
  console.log('üß† Step 5: Generating AI response...');

  let aiResponse: string;
  let shouldHandoffFromAI = false;
  let handoffReasonFromAI: string | undefined;

  if (isFullAIIntelligenceEnabled()) {
    console.log('üéØ Using AI Orchestrator (full intelligence enabled)');

    // NEW PATH: Full AI Intelligence with Orchestrator
    const orchestrator = getAIOrchestrator();
    const orchestratorResponse = await orchestrator.processMessage({
      conversationId: data.conversationId,
      contactId: data.contactId,
      userMessage: data.userMessage || '',
      leadData: data.processedLeadData,
      brokerPersona: persona
    });

    aiResponse = orchestratorResponse.content;
    shouldHandoffFromAI = orchestratorResponse.shouldHandoff;
    handoffReasonFromAI = orchestratorResponse.handoffReason;

    console.log(`‚úÖ AI Orchestrator response generated (${aiResponse.length} chars)`);
    console.log(`   Model: ${orchestratorResponse.model}`);
    console.log(`   Intent: ${orchestratorResponse.intent}`);
    console.log(`   Tokens: ${orchestratorResponse.tokensUsed}`);

  } else {
    console.log('üí¨ Using legacy AI service (orchestrator disabled)');

    // LEGACY PATH: Direct AI generation
    aiResponse = await generateBrokerResponse({
      message: data.userMessage || '',
      persona,
      leadData: data.processedLeadData,
      conversationId: data.conversationId,
      conversationHistory: [], // TODO: Fetch from Chatwoot in future enhancement
    });

    console.log(`‚úÖ Legacy AI response generated (${aiResponse.length} chars)`);
  }

  // STEP 6: Send response to Chatwoot (NEW METHOD - Phase 2)
  // Uses new sendMessage() method added to ChatwootClient
  console.log('üì§ Step 6: Sending AI response to Chatwoot...');
  const chatwootClient = new ChatwootClient();
  const result = await chatwootClient.sendMessage(
    data.conversationId,
    aiResponse
  );
  console.log('‚úÖ Message sent to Chatwoot, message_id:', result.message_id);

  // STEP 7: Check for handoff
  // Week 5: Check both urgency analysis AND AI Orchestrator recommendation
  const needsHandoff = urgency.escalate || shouldHandoffFromAI;

  if (needsHandoff) {
    const handoffReason = handoffReasonFromAI ||
                          (urgency.escalate ? 'Customer requested escalation' : 'Complex question');

    console.log('üö® Step 7: Escalation needed, triggering handoff...');
    console.log(`   Reason: ${handoffReason}`);

    // Post activity message
    await chatwootClient.createActivityMessage(
      data.conversationId,
      '‚ö†Ô∏è This conversation requires human attention'
    );

    // Update conversation status (triggers human agent notification)
    await chatwootClient.updateConversationCustomAttributes(
      data.conversationId,
      {
        ai_status: 'handoff_requested',
        handoff_reason: handoffReason,
        handoff_at: new Date().toISOString(),
      }
    );

    // Release broker capacity (EXISTING FUNCTION)
    await releaseBrokerCapacity(broker.id);
    console.log('‚úÖ Broker capacity released after handoff');

    // Update metrics with handoff flag (EXISTING FUNCTION)
    await updateBrokerMetrics(
      data.conversationId,
      broker.id,
      1, // message_count
      true, // handoffTriggered
      handoffReason
    );

    console.log('‚úÖ Handoff completed');
    return; // Don't continue processing
  }

  // STEP 8: Update metrics (EXISTING FUNCTION)
  // No handoff - normal conversation continues
  console.log('üìà Step 8: Updating broker metrics...');
  await updateBrokerMetrics(
    data.conversationId,
    broker.id,
    1, // message_count
    false, // handoffTriggered
    undefined
  );
  console.log('‚úÖ Metrics updated');

  // Note: Broker remains assigned (capacity NOT released until handoff or conversation ends)
}

/**
 * Helper function for delays
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Lazy initialization for BullMQ worker
 *
 * IMPORTANT: Uses lazy initialization to prevent build-time execution.
 * Environment variables (REDIS_URL) are only available at runtime in Docker builds.
 *
 * CONFIGURATION:
 * - Concurrency: Set via WORKER_CONCURRENCY env var (default: 3)
 * - Rate limit: Set via QUEUE_RATE_LIMIT env var (default: 10/second)
 * - Connection: Uses Redis config from redis-config.ts
 *
 * WORKER LIFECYCLE:
 * - Initialized by worker-manager.ts
 * - Runs in server environment only (not client-side)
 * - Gracefully shuts down on SIGTERM/SIGINT
 */
let _brokerWorker: Worker<BrokerConversationJob> | null = null;

export function getBrokerWorker(): Worker<BrokerConversationJob> {
  if (!_brokerWorker) {
    _brokerWorker = new Worker<BrokerConversationJob>(
      'broker-conversations',
      processConversationJob,
      {
        connection: getRedisConnection(),
        concurrency: parseInt(process.env.WORKER_CONCURRENCY || '3'),
        limiter: {
          max: parseInt(process.env.QUEUE_RATE_LIMIT || '10'),
          duration: 1000,
        },
      }
    );

    // Set up event handlers once
    _brokerWorker.on('completed', (job) => {
      console.log(`‚úÖ Worker completed job ${job.id}`);
    });

    _brokerWorker.on('failed', (job, err) => {
      console.error(`‚ùå Worker failed job ${job?.id}:`, err.message);
    });

    _brokerWorker.on('error', (err) => {
      console.error('‚ùå Worker error:', err);
    });

    // Graceful shutdown handlers
    const shutdown = async (signal: string) => {
      console.log(`\n‚ö†Ô∏è ${signal} received, gracefully shutting down worker...`);
      await _brokerWorker!.close();
      console.log('‚úÖ Worker closed successfully');
      process.exit(0);
    };

    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGINT', () => shutdown('SIGINT'));

    console.log('üöÄ BullMQ worker initialized and ready to process jobs');
    console.log(`   Concurrency: ${process.env.WORKER_CONCURRENCY || 3}`);
    console.log(`   Rate limit: ${process.env.QUEUE_RATE_LIMIT || 10}/second`);
    console.log(`   Environment: ${process.env.NODE_ENV}`);
  }
  return _brokerWorker;
}
